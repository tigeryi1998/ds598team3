{
	"name": "Weather_Historical",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "weathersample",
						"type": "DatasetReference"
					},
					"name": "source1"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "silver_weather",
						"type": "DatasetReference"
					},
					"name": "sink1"
				}
			],
			"transformations": [
				{
					"name": "flatten1"
				},
				{
					"name": "flatten2"
				},
				{
					"name": "derivedColumn1"
				},
				{
					"name": "filter1"
				},
				{
					"name": "derivedColumn2"
				},
				{
					"name": "select1"
				}
			],
			"scriptLines": [
				"source(output(",
				"          message as string,",
				"          cod as string,",
				"          city_id as integer,",
				"          calctime as double,",
				"          cnt as integer,",
				"          list as (dt as integer, main as (temp as double, feels_like as double, pressure as integer, humidity as integer, temp_min as double, temp_max as double), wind as (speed as double, deg as integer, gust as double), clouds as (all as integer), weather as (id as integer, main as string, description as string, icon as string)[], rain as ({1h} as double))[]",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     inferDriftedColumnTypes: true,",
				"     ignoreNoFilesFound: false,",
				"     documentForm: 'documentPerLine') ~> source1",
				"source1 foldDown(unroll(list, list),",
				"     mapColumn(",
				"          message,",
				"          cod,",
				"          city_id,",
				"          calctime,",
				"          cnt,",
				"          dt = list.dt,",
				"          main = list.main,",
				"          wind = list.wind,",
				"          clouds = list.clouds,",
				"          weather = list.weather,",
				"          rain = list.rain",
				"     ),",
				"     skipDuplicateMapInputs: false,",
				"     skipDuplicateMapOutputs: false) ~> flatten1",
				"flatten1 foldDown(unroll(weather, weather),",
				"     mapColumn(",
				"          calctime,",
				"          city_id,",
				"          cnt,",
				"          cod,",
				"          message,",
				"          clouds_all = clouds.all,",
				"          timestamp = dt,",
				"          feels_like = main.feels_like,",
				"          humidity = main.humidity,",
				"          pressure = main.pressure,",
				"          temp = main.temp,",
				"          temp_max = main.temp_max,",
				"          temp_min = main.temp_min,",
				"          weather_description = weather.description,",
				"          weather_icon = weather.icon,",
				"          weather_id = weather.id,",
				"          weather_main = weather.main,",
				"          wind_deg = wind.deg,",
				"          wind_gust = wind.gust,",
				"          wind_speed = wind.speed,",
				"          rain_1h = rain.{1h}",
				"     ),",
				"     skipDuplicateMapInputs: false,",
				"     skipDuplicateMapOutputs: false) ~> flatten2",
				"flatten2 derive(corrected_timestamp = iif(length(toString(timestamp)) == 10, toInteger(timestamp), toInteger(null())),",
				"          location = 'Boston') ~> derivedColumn1",
				"derivedColumn1 filter((!isNull(corrected_timestamp))&&(!isNull(temp))&&(!isNull(humidity))) ~> filter1",
				"filter1 derive(date_time = toTimestamp(toLong(corrected_timestamp) * 1000),",
				"          id = concat(location, toString(corrected_timestamp)),",
				"          temp_C = round(temp - 273.15, 2),",
				"          temp_min_C = round(temp_min - 273.15, 2),",
				"          temp_max_C = round(temp_max - 273.15, 2),",
				"          feels_like_C = round(feels_like - 273.15, 2),",
				"          temp_F = round((temp - 273.15) * 1.8 + 32, 2),",
				"          temp_min_F = round((temp_min - 273.15) * 1.8 + 32, 2),",
				"          temp_max_F = round((temp_max - 273.15) * 1.8 + 32, 0),",
				"          feels_like_F = round((feels_like - 273.15) * 1.8 + 32, 0),",
				"          lat = 42.3601,",
				"          lon = -71.0589,",
				"          weather_id_value = toInteger(split(toString(weather_id), ':')[1]),",
				"          weather_mail_value = split(toString(weather_main), ': ')[1],",
				"          weather_description_value = split(toString(weather_description), ': ')[1],",
				"          weather_icon_value = split(toString(weather_icon), ': ')[1],",
				"          rain_1h = iif(isNull(rain_1h), toFloat(0.0), toFloat(rain_1h))) ~> derivedColumn2",
				"derivedColumn2 select(mapColumn(",
				"          clouds_all,",
				"          feels_like_K = feels_like,",
				"          humidity,",
				"          pressure,",
				"          temp_K = temp,",
				"          temp_max_K = temp_max,",
				"          temp_min_K = temp_min,",
				"          wind_deg,",
				"          wind_gust,",
				"          wind_speed,",
				"          rain_1h,",
				"          corrected_timestamp,",
				"          location,",
				"          date_time,",
				"          id,",
				"          temp_C,",
				"          temp_min_C,",
				"          temp_max_C,",
				"          feels_like_C,",
				"          temp_F,",
				"          temp_min_F,",
				"          temp_max_F,",
				"          feels_like_F,",
				"          lat,",
				"          lon,",
				"          weather_id_value,",
				"          weather_mail_value,",
				"          weather_description_value,",
				"          weather_icon_value",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> select1",
				"select1 sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     input(",
				"          ride_id as string,",
				"          rideable_type as string,",
				"          started_at as timestamp,",
				"          ended_at as timestamp,",
				"          start_station_name as string,",
				"          start_station_id as string,",
				"          end_station_name as string,",
				"          end_station_id as string,",
				"          start_lat as double,",
				"          start_lng as double,",
				"          end_lat as double,",
				"          end_lng as double,",
				"          member_casual as string,",
				"          is_bike_lost as long,",
				"          is_return_to_dock as long,",
				"          is_start_from_dock as long,",
				"          distance as double,",
				"          duration as double,",
				"          speed_ms as double,",
				"          speed_kmh as double",
				"     ),",
				"     format: 'parquet',",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     partitionBy('hash', 1)) ~> sink1"
			]
		}
	}
}